[{"target_argument": "nums", "change_to": "values", "original_function": "def foo(nums: list[int]):\n    n = len(nums)\n    def inner_func(i):\n        if i == n:\n            return 1\n        nums[i] += inner_func(i+1)\n        return nums[i]\n    return inner_func(0)", "changed_function": "def foo(values: list[int]):\n    n = len(values)\n    def inner_func(i):\n        if i == n:\n            return 1\n        values[i] += inner_func(i+1)\n        return values[i]\n    return inner_func(0)", "function_call": "foo(nums)", "function_name": "foo", "inputs": ["[1, 2, 3]", "[4, 5, 6, 7]", "[8, 9]", "[10]", "[]"]}, {"target_argument": "graph", "change_to": "adj_list", "original_function": "def bar(graph: dict):\n    def dfs(node, visited):\n        visited.add(node)\n        for neighbor in graph[node]:\n            if neighbor not in visited:\n                dfs(neighbor, visited)\n    num_components = 0\n    visited = set()\n    for node in graph:\n        if node not in visited:\n            dfs(node, visited)\n            num_components += 1\n    return num_components", "changed_function": "def bar(adj_list: dict):\n    def dfs(node, visited):\n        visited.add(node)\n        for neighbor in adj_list[node]:\n            if neighbor not in visited:\n                dfs(neighbor, visited)\n    num_components = 0\n    visited = set()\n    for node in adj_list:\n        if node not in visited:\n            dfs(node, visited)\n            num_components += 1\n    return num_components", "function_call": "bar(graph)", "function_name": "bar", "inputs": ["{1: [2, 3], 2: [1], 3: [1]}", "{1: [2], 2: [1], 3: [], 4: [5], 5: [4]}", "{1: []}", "{}", "{1: [1]}"]}, {"target_argument": "nums", "change_to": "data", "original_function": "def baz(nums: list[int]):\n    def merge_sort(arr):\n        if len(arr) <= 1:\n            return arr\n        mid = len(arr) // 2\n        left = merge_sort(arr[:mid])\n        right = merge_sort(arr[mid:])\n        return merge(left, right)\n\n    def merge(left, right):\n        merged = []\n        i = j = 0\n        while i < len(left) and j < len(right):\n            if left[i] <= right[j]:\n                merged.append(left[i])\n                i += 1\n            else:\n                merged.append(right[j])\n                j += 1\n        merged.extend(left[i:])\n        merged.extend(right[j:])\n        return merged\n    return merge_sort(nums)", "changed_function": "def baz(data: list[int]):\n    def merge_sort(arr):\n        if len(arr) <= 1:\n            return arr\n        mid = len(arr) // 2\n        left = merge_sort(arr[:mid])\n        right = merge_sort(arr[mid:])\n        return merge(left, right)\n\n    def merge(left, right):\n        merged = []\n        i = j = 0\n        while i < len(left) and j < len(right):\n            if left[i] <= right[j]:\n                merged.append(left[i])\n                i += 1\n            else:\n                merged.append(right[j])\n                j += 1\n        merged.extend(left[i:])\n        merged.extend(right[j:])\n        return merged\n    return merge_sort(data)", "function_call": "baz(nums)", "function_name": "baz", "inputs": ["[3, 1, 4, 2]", "[1, 2, 3, 4, 5]", "[5, 4, 3, 2, 1]", "[1, 1, 1, 1]", "[]"]}, {"target_argument": "s", "change_to": "text", "original_function": "def qux(s: str):\n    def is_palindrome(start, end):\n        while start < end:\n            if s[start] != s[end]:\n                return False\n            start += 1\n            end -= 1\n        return True\n    longest = ''\n    for i in range(len(s)):\n        for j in range(i, len(s)):\n            if is_palindrome(i, j) and j - i + 1 > len(longest):\n                longest = s[i:j+1]\n    return longest", "changed_function": "def qux(text: str):\n    def is_palindrome(start, end):\n        while start < end:\n            if text[start] != text[end]:\n                return False\n            start += 1\n            end -= 1\n        return True\n    longest = ''\n    for i in range(len(text)):\n        for j in range(i, len(text)):\n            if is_palindrome(i, j) and j - i + 1 > len(longest):\n                longest = text[i:j+1]\n    return longest", "function_call": "qux(s)", "function_name": "qux", "inputs": ["\"racecar\"", "\"ababa\"", "\"a\"", "\"\"", "\"abaxyzzyxf\""]}, {"target_argument": "matrix", "change_to": "grid", "original_function": "def quux(matrix: list[list[int]]):\n    rows = len(matrix)\n    cols = len(matrix[0])\n    def get_neighbors(row, col):\n        neighbors = []\n        for i, j in [(row-1, col), (row+1, col), (row, col-1), (row, col+1)]:\n            if 0 <= i < rows and 0 <= j < cols:\n                neighbors.append((i, j))\n        return neighbors\n    visited = set()\n    def dfs(row, col):\n        visited.add((row, col))\n        for r, c in get_neighbors(row, col):\n            if (r, c) not in visited and matrix[r][c] == 1:\n                dfs(r, c)\n    num_islands = 0\n    for row in range(rows):\n        for col in range(cols):\n            if matrix[row][col] == 1 and (row, col) not in visited:\n                dfs(row, col)\n                num_islands += 1\n    return num_islands", "changed_function": "def quux(grid: list[list[int]]):\n    rows = len(grid)\n    cols = len(grid[0])\n    def get_neighbors(row, col):\n        neighbors = []\n        for i, j in [(row-1, col), (row+1, col), (row, col-1), (row, col+1)]:\n            if 0 <= i < rows and 0 <= j < cols:\n                neighbors.append((i, j))\n        return neighbors\n    visited = set()\n    def dfs(row, col):\n        visited.add((row, col))\n        for r, c in get_neighbors(row, col):\n            if (r, c) not in visited and grid[r][c] == 1:\n                dfs(r, c)\n    num_islands = 0\n    for row in range(rows):\n        for col in range(cols):\n            if grid[row][col] == 1 and (row, col) not in visited:\n                dfs(row, col)\n                num_islands += 1\n    return num_islands", "function_call": "quux(matrix)", "function_name": "quux", "inputs": ["[[1, 1, 0, 0, 0], [1, 1, 0, 0, 0], [0, 0, 1, 0, 0], [0, 0, 0, 1, 1]]", "[[1, 1, 1], [0, 1, 0], [1, 1, 1]]", "[[0, 0, 0], [0, 0, 0], [0, 0, 0]]", "[[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]]", "[[1]]"]}]