[{"target_argument": "nums", "change_to": "lst", "original_function": "def sort_and_square(nums: list[int]):\n    nums.sort()\n    def square(x):\n        return x * x\n    return list(map(square, nums))", "changed_function": "\ndef sort_and_square(lst: list[int]): ", "function_call": "sort_and_square(nums=[1, 2, 3, 4, 5])", "function_name": "sort_and_square", "inputs": ["[1, 2, 3, 4, 5]", "[5, 4, 3, 2, 1]", "[1, 2, 3, 2, 1]", "[1]", "[]"]}, {"target_argument": "graph", "change_to": "g", "original_function": "def dfs(graph: dict, start_node):\n    visited = set()\n    def dfs_helper(node):\n        visited.add(node)\n        for neighbor in graph.get(node, []):\n            if neighbor not in visited:\n                dfs_helper(neighbor)\n    dfs_helper(start_node)\n    return visited", "changed_function": "\ndef dfs(g, start_node):\n    visited = set()\n    def dfs_helper(node):\n        visited.add(node)\n        for neighbor in g.get(node, []):\n            if neighbor not in visited:\n                dfs_helper(neighbor)\n    dfs_helper(start_node)\n    return 8dfss8\n\nprint(dfs({8: []}, \"A\"))\n", "function_call": "dfs(graph={'A': ['B', 'C'], 'B': ['D', 'E'], 'C': ['F'], 'D': [], 'E': ['F'], 'F': []}, start_node='A')", "function_name": "dfs", "inputs": ["{'A': ['B', 'C'], 'B': ['D', 'E'], 'C': ['F'], 'D': [], 'E': ['F'], 'F': []}, 'A'", "{'A': ['B'], 'B': ['A']}, 'A'", "{}, 'A'", "{'A': ['B'], 'B': []}, 'B'", "{'A': ['A']}, 'A'"]}, {"target_argument": "n", "change_to": "num", "original_function": "def is_prime(n: int):\n  if n <= 1:\n    return False\n  for i in range(2, int(n**0.5) + 1):\n    if n % i == 0:\n      return False\n  return True", "changed_function": "\ndef is_prime(num: int):\n  # Simple cases that cannot be prime.\n  if num <= 1:\n    return False\n\n  # In python, we easily determine if num is a whole number by simply checking if num % 1.0 == 0\n  # Simplest test possible\n  if num % 1.0 == 0:\n    return False\n\n  # Use a helper function to determine if num is divisible by any num < 20, if so, then its composite.\n  if", "function_call": "is_prime(n=7)", "function_name": "is_prime", "inputs": ["7", "11", "2", "1", "4"]}, {"target_argument": "data", "change_to": "nums", "original_function": "def binary_search(data: list[int], target: int):\n    left, right = 0, len(data) - 1\n    while left <= right:\n        mid = (left + right) // 2\n        if data[mid] == target:\n            return mid\n        elif data[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n    return -1", "changed_function": "\ndef binary_search(nums: list[int], target: int):\n    data = nums  # data is the source, we can move the parameter to anywhere else as long as it behaves the same as source.\n    ", "function_call": "binary_search(data=[2, 5, 7, 8, 11, 12], target=13)", "function_name": "binary_search", "inputs": ["[2, 5, 7, 8, 11, 12], 13", "[2, 5, 7, 8, 11, 12], 12", "[2, 5, 7, 8, 11, 12], 2", "[2, 5, 7, 8, 11, 12], 9", "[2, 2, 2, 2, 2, 2], 2"]}, {"target_argument": "s", "change_to": "text", "original_function": "def is_palindrome(s: str):\n    s = ''.join(c for c in s if c.isalnum()).lower()\n    left, right = 0, len(s) - 1\n    while left < right:\n        if s[left] != s[right]:\n            return False\n        left += 1\n        right -= 1\n    return True", "changed_function": "\ndef is_palindrome(text: str):\n    text = ''.join(c for c in text if c.isalnum()).lower()\n    left, right = 0, len(text) - 1\n    while left < right:\n        if text[left]!= text[right]:\n            return False\n        left += 1\n        right -= 1\n    return True\n", "function_call": "is_palindrome(s='racecar')", "function_name": "is_palindrome", "inputs": ["'racecar'", "'madam'", "'A man, a plan, a canal: Panama'", "'race a car'", "' '"]}, {"target_argument": "data", "change_to": "value", "original_function": "def binary_search_tree(data):\n    def insert(root, data):\n        if root is None:\n            return {'data': data, 'left': None, 'right': None}\n        else:\n            if data < root['data']:\n                root['left'] = insert(root['left'], data)\n            else:\n                root['right'] = insert(root['right'], data)\n            return root\n    return insert(None, data)", "changed_function": "\ndef binary_search_tree(value):\n    def insert(root, value):\n        if root is None:\n            return {'data': value, 'left': None, 'right': None}\n        else:\n            if value < root['data']:\n                root['left'] = insert(root['left'], value)\n            else:\n                root['right'] = insert(root['right'], value)\n            return root\n    return insert(None, value)\n", "function_call": "binary_search_tree(data = 5)", "function_name": "binary_search_tree", "inputs": ["10", "5", "-3", "7.5", "22"]}, {"target_argument": "nums", "change_to": "array", "original_function": "def quick_sort(nums):\n    if len(nums) <= 1:\n        return nums\n    pivot = nums[0]\n    left = [x for x in nums[1:] if x <= pivot]\n    right = [x for x in nums[1:] if x > pivot]\n    return quick_sort(left) + [pivot] + quick_sort(right)", "changed_function": "\ndef quick_sort(array):\n    if len(array) <= 1:\n        return array\n    pivot = array[0]\n    left = [x for x in array[1:] if x <= pivot]\n    right = [x for x in array[1:] if x > pivot]\n    return quick_sort(left) + [pivot] + quick_sort(right)\n", "function_call": "quick_sort(nums = [3, 7, 8, 5, 2, 1, 9, 5, 4])", "function_name": "quick_sort", "inputs": ["[3, 7, 8, 5, 2, 1, 9, 5, 4]", "[1, 2, 3, 4, 5]", "[5, 4, 3, 2, 1]", "[]", "[1]"]}, {"target_argument": "graph", "change_to": "network", "original_function": "def find_shortest_path(graph, start, end):\n    queue = [[start]]\n    visited = {start}\n    if start == end:\n      return [start]\n    while queue:\n        path = queue.pop(0)\n        node = path[-1]\n        for neighbor in graph[node]:\n            if neighbor not in visited:\n                new_path = list(path)\n                new_path.append(neighbor)\n                queue.append(new_path)\n                visited.add(neighbor)\n                if neighbor == end:\n                    return new_path\n    return None", "changed_function": "\ndef find_shortest_path(network,n1,n2):\n    queue = [[n1]]\n    visited = {n1}\n    if n1 == n2:\n        return [n1]\n    while queue:\n        path = queue.pop(0)\n        node = path[-1]\n", "function_call": "find_shortest_path(graph = {'A': ['B', 'C'],\n               'B': ['C', 'D'],\n               'C': ['D'],\n               'D': ['C'],\n               'E': ['F'],\n               'F': ['C']}, start = 'A', end = 'D')", "function_name": "find_shortest_path", "inputs": ["{'A': ['B', 'C'], 'B': ['C', 'D'], 'C': ['D'], 'D': ['C'], 'E': ['F'], 'F': ['C']}, 'A', 'D'", "{'A': ['B'], 'B': ['A']}, 'A', 'B'", "{'X': ['Y'], 'Y': ['Z'], 'Z': []}, 'X', 'Z'", "{'start': ['end'], 'end': []}, 'start', 'end'", "{'A': ['B'], 'B': ['C', 'D'], 'C': ['A'], 'D': []}, 'A', 'D']"]}, {"target_argument": "n", "change_to": "number", "original_function": "def factorial(n):\n    if n == 0:\n        return 1\n    else:\n        return n * factorial(n-1)", "changed_function": "\ndef factorial(number):\n    if number == 0:\n        return 1\n    else:\n        return number * factorial(number - 1)\n", "function_call": "factorial(n = 5)", "function_name": "factorial", "inputs": ["0", "1", "2", "5", "10"]}]