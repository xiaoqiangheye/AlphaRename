[{"function_name": "recursive_sum", "function": "def recursive_sum(lst):\n    if not lst:\n        return 0\n    else:\n        return lst[0] + recursive_sum(lst[1:])", "command": "recursive_sum([1,2,3,4,5])", "traces": "1. recursive_sum([1,2,3,4,5]) -> 1 + recursive_sum([2,3,4,5]) // Base case not met, recursive call.\n2. 1 + recursive_sum([2,3,4,5]) -> 1 + (2 + recursive_sum([3,4,5])) // Recursive call.\n3. 1 + (2 + recursive_sum([3,4,5])) -> 1 + (2 + (3 + recursive_sum([4,5]))) // Recursive call.\n4. 1 + (2 + (3 + recursive_sum([4,5]))) -> 1 + (2 + (3 + (4 + recursive_sum([5])))) // Recursive call.\n5. 1 + (2 + (3 + (4 + recursive_sum([5])))) -> 1 + (2 + (3 + (4 + (5 + recursive_sum([]))))) // Recursive call.\n6. 1 + (2 + (3 + (4 + (5 + recursive_sum([]))))) -> 1 + (2 + (3 + (4 + (5 + 0)))) // Base case met, recursive_sum([]) returns 0.\n7. 1 + (2 + (3 + (4 + (5 + 0)))) -> 1 + (2 + (3 + (4 + 5))) // Arithmetic operation.\n8. 1 + (2 + (3 + (4 + 5))) -> 1 + (2 + (3 + 9)) // Arithmetic operation.\n9. 1 + (2 + (3 + 9)) -> 1 + (2 + 12) // Arithmetic operation.\n10. 1 + (2 + 12) -> 1 + 14 // Arithmetic operation.\n11. 1 + 14 -> 15 // Arithmetic operation.", "output": 15}, {"function_name": "map_add_one", "function": "def map_add_one(lst):\n    if not lst:\n        return []\n    else:\n        return [lst[0] + 1] + map_add_one(lst[1:])", "command": "map_add_one([1,2,3])", "traces": "1. map_add_one([1,2,3]) -> [1+1] + map_add_one([2,3]) //Recursive call, adds 1 to the first element.\n2. [1+1] + map_add_one([2,3]) -> [2] + map_add_one([2,3]) //Arithmetic operation.\n3. [2] + map_add_one([2,3]) -> [2] + [2+1] + map_add_one([3]) //Recursive call, adds 1 to the first element.\n4. [2] + [2+1] + map_add_one([3]) -> [2] + [3] + map_add_one([3]) //Arithmetic operation.\n5. [2] + [3] + map_add_one([3]) -> [2] + [3] + [3+1] + map_add_one([]) //Recursive call, adds 1 to the first element.\n6. [2] + [3] + [3+1] + map_add_one([]) -> [2] + [3] + [4] + [] //Base case, empty list returns empty list.\n7. [2] + [3] + [4] + [] -> [2,3,4] //List concatenation.", "output": [2, 3, 4]}, {"function_name": "higher_order_example", "function": "def higher_order_example(x, func):\n    return func(func(x))\ndef square(x):\n    return x * x", "command": "higher_order_example(2, square)", "traces": "1. higher_order_example(2, square) -> square(square(2)) //Function application.\n2. square(square(2)) -> square(2*2) //Function application, square(2) evaluates to 4.\n3. square(2*2) -> square(4) //Arithmetic operation.\n4. square(4) -> 4*4 //Function application, square(4) evaluates to 16.\n5. 4*4 -> 16 //Arithmetic operation.", "output": 16}, {"function_name": "compose_functions", "function": "def compose_functions(f, g):\n    return lambda x: f(g(x))\ndef add_one(x):\n    return x + 1\ndef multiply_by_two(x):\n    return x * 2", "command": "compose_functions(add_one, multiply_by_two)(3)", "traces": "1. compose_functions(add_one, multiply_by_two)(3) -> (lambda x: add_one(multiply_by_two(x)))(3) //Function application, returns a lambda function.\n2. (lambda x: add_one(multiply_by_two(x)))(3) -> add_one(multiply_by_two(3)) //Lambda function application.\n3. add_one(multiply_by_two(3)) -> add_one(3*2) //Function application, multiply_by_two(3) evaluates to 6.\n4. add_one(3*2) -> add_one(6) //Arithmetic operation.\n5. add_one(6) -> 6 + 1 //Function application, add_one(6) evaluates to 7.\n6. 6 + 1 -> 7 //Arithmetic operation.", "output": 7}, {"function_name": "fib_lambda", "function": "fib = lambda n: n if n <= 1 else fib(n-1) + fib(n-2)", "command": "fib(5)", "traces": "1. fib(5) -> fib(4) + fib(3) //Recursive call.\n2. fib(4) + fib(3) -> (fib(3) + fib(2)) + fib(3) //Recursive call for fib(4).\n3. (fib(3) + fib(2)) + fib(3) -> ((fib(2) + fib(1)) + (fib(1) + fib(0))) + (fib(2) + fib(1)) //Recursive calls for fib(3) and fib(2).\n4. ((fib(2) + fib(1)) + (fib(1) + fib(0))) + (fib(2) + fib(1)) -> (((fib(1) + fib(0)) + 1) + (1 + 0)) + ((fib(1) + fib(0)) + 1) //Recursive calls for fib(2) and fib(1).\n5. (((fib(1) + fib(0)) + 1) + (1 + 0)) + ((fib(1) + fib(0)) + 1) -> (((1 + 0) + 1) + (1 + 0)) + ((1 + 0) + 1) //Base cases fib(1) = 1, fib(0) = 0.\n6. (((1 + 0) + 1) + (1 + 0)) + ((1 + 0) + 1) -> ((1 + 1) + 1) + (1 + 1) //Arithmetic operations.\n7. ((1 + 1) + 1) + (1 + 1) -> (2 + 1) + 2 //Arithmetic operations.\n8. (2 + 1) + 2 -> 3 + 2 //Arithmetic operations.\n9. 3 + 2 -> 5 //Arithmetic operations.", "output": 5}, {"function_name": "recursive_sum", "function": "def recursive_sum(lst):\n    if not lst:\n        return 0\n    else:\n        return lst[0] + recursive_sum(lst[1:])", "command": "recursive_sum([1,2,3,4,5])", "traces": "1. recursive_sum([1,2,3,4,5]) -> 1 + recursive_sum([2,3,4,5]) // Base case not met, recursive call\n2. 1 + recursive_sum([2,3,4,5]) -> 1 + (2 + recursive_sum([3,4,5])) // Recursive call\n3. 1 + (2 + recursive_sum([3,4,5])) -> 1 + (2 + (3 + recursive_sum([4,5]))) // Recursive call\n4. 1 + (2 + (3 + recursive_sum([4,5]))) -> 1 + (2 + (3 + (4 + recursive_sum([5])))) // Recursive call\n5. 1 + (2 + (3 + (4 + recursive_sum([5])))) -> 1 + (2 + (3 + (4 + (5 + recursive_sum([]))))) // Recursive call\n6. 1 + (2 + (3 + (4 + (5 + recursive_sum([]))))) -> 1 + (2 + (3 + (4 + (5 + 0)))) // Base case met, returns 0\n7. 1 + (2 + (3 + (4 + (5 + 0)))) -> 1 + (2 + (3 + (4 + 5))) //Arithmetic\n8. 1 + (2 + (3 + (4 + 5))) -> 1 + (2 + (3 + 9)) //Arithmetic\n9. 1 + (2 + (3 + 9)) -> 1 + (2 + 12) //Arithmetic\n10. 1 + (2 + 12) -> 1 + 14 //Arithmetic\n11. 1 + 14 -> 15 //Arithmetic", "output": 15}, {"function_name": "map_add_one", "function": "def map_add_one(lst):\n    if not lst:\n        return []\n    else:\n        return [lst[0] + 1] + map_add_one(lst[1:])", "command": "map_add_one([1,2,3])", "traces": "1. map_add_one([1,2,3]) -> [1+1] + map_add_one([2,3]) //Base case not met, recursive call\n2. [1+1] + map_add_one([2,3]) -> [2] + map_add_one([2,3]) //Arithmetic\n3. [2] + map_add_one([2,3]) -> [2] + [2+1] + map_add_one([3]) //Recursive call\n4. [2] + [2+1] + map_add_one([3]) -> [2] + [3] + map_add_one([3]) //Arithmetic\n5. [2] + [3] + map_add_one([3]) -> [2] + [3] + [3+1] + map_add_one([]) //Recursive call\n6. [2] + [3] + [3+1] + map_add_one([]) -> [2] + [3] + [4] + [] //Base case met, returns []\n7. [2] + [3] + [4] + [] -> [2,3,4] //List concatenation", "output": [2, 3, 4]}, {"function_name": "higher_order_apply", "function": "def higher_order_apply(f, x):\n    return f(x)\n\ndef add_five(x):\n    return x + 5\n\ndef square(x):\n  return x*x", "command": "higher_order_apply(lambda x: square(add_five(x)), 2)", "traces": "1. higher_order_apply(lambda x: square(add_five(x)), 2) -> (lambda x: square(add_five(x)))(2) //Function application\n2. (lambda x: square(add_five(x)))(2) -> square(add_five(2)) //Lambda function application\n3. square(add_five(2)) -> square(2 + 5) //Function application\n4. square(2 + 5) -> square(7) //Arithmetic\n5. square(7) -> 7 * 7 //Function application\n6. 7 * 7 -> 49 //Arithmetic", "output": 49}, {"function_name": "fib_recursive", "function": "def fib_recursive(n):\n    if n <= 1:\n        return n\n    else:\n        return fib_recursive(n-1) + fib_recursive(n-2)", "command": "fib_recursive(5)", "traces": "1. fib_recursive(5) -> fib_recursive(4) + fib_recursive(3) //Recursive call\n2. fib_recursive(4) + fib_recursive(3) -> (fib_recursive(3) + fib_recursive(2)) + fib_recursive(3) //Recursive call\n3. (fib_recursive(3) + fib_recursive(2)) + fib_recursive(3) -> ((fib_recursive(2) + fib_recursive(1)) + (fib_recursive(1) + fib_recursive(0))) + (fib_recursive(2) + fib_recursive(1)) //Recursive calls\n4. ((fib_recursive(2) + fib_recursive(1)) + (fib_recursive(1) + fib_recursive(0))) + (fib_recursive(2) + fib_recursive(1)) -> (((fib_recursive(1) + fib_recursive(0)) + 1) + (1 + 0)) + ((fib_recursive(1) + fib_recursive(0)) + 1) //Recursive calls\n5. (((fib_recursive(1) + fib_recursive(0)) + 1) + (1 + 0)) + ((fib_recursive(1) + fib_recursive(0)) + 1) -> (((1 + 0) + 1) + 1) + ((1 + 0) + 1) //Base cases\n6. (((1 + 0) + 1) + 1) + ((1 + 0) + 1) -> (1 + 1 + 1) + 1 //Arithmetic\n7. (1 + 1 + 1) + 1 -> 3 + 1 //Arithmetic\n8. 3 + 1 -> 4 //Arithmetic\n9. 4 + 3 -> 5", "output": 5}, {"function_name": "compose_functions", "function": "def compose_functions(f, g):\n    return lambda x: f(g(x))\n\ndef add_one(x):\n    return x + 1\n\ndef multiply_by_two(x):\n    return x * 2", "command": "compose_functions(multiply_by_two, add_one)(5)", "traces": "1. compose_functions(multiply_by_two, add_one)(5) -> (lambda x: multiply_by_two(add_one(x)))(5)  //Compose functions\n2. (lambda x: multiply_by_two(add_one(x)))(5) -> multiply_by_two(add_one(5)) //Lambda function application\n3. multiply_by_two(add_one(5)) -> multiply_by_two(5 + 1) //Function application\n4. multiply_by_two(5 + 1) -> multiply_by_two(6) //Arithmetic\n5. multiply_by_two(6) -> 6 * 2 //Function application\n6. 6 * 2 -> 12 //Arithmetic", "output": 12}, {"function_name": "recursive_sum", "function": "def recursive_sum(lst):\n    if not lst:\n        return 0\n    else:\n        return lst[0] + recursive_sum(lst[1:])", "command": "recursive_sum([1, 2, 3, 4, 5])", "traces": "1. recursive_sum([1, 2, 3, 4, 5]) -> 1 + recursive_sum([2, 3, 4, 5]) //Recursive call with the tail of the list\n2. 1 + recursive_sum([2, 3, 4, 5]) -> 1 + (2 + recursive_sum([3, 4, 5])) //Further recursive call\n3. 1 + (2 + recursive_sum([3, 4, 5])) -> 1 + (2 + (3 + recursive_sum([4, 5]))) //Another recursive call\n4. 1 + (2 + (3 + recursive_sum([4, 5]))) -> 1 + (2 + (3 + (4 + recursive_sum([5])))) //Recursive call\n5. 1 + (2 + (3 + (4 + recursive_sum([5])))) -> 1 + (2 + (3 + (4 + (5 + recursive_sum([]))))) //Base case reached: empty list\n6. 1 + (2 + (3 + (4 + (5 + recursive_sum([]))))) -> 1 + (2 + (3 + (4 + (5 + 0)))) //Base case returns 0\n7. 1 + (2 + (3 + (4 + (5 + 0)))) -> 1 + (2 + (3 + (4 + 5))) //Simplifying the expression\n8. 1 + (2 + (3 + (4 + 5))) -> 1 + (2 + (3 + 9)) //Simplifying\n9. 1 + (2 + (3 + 9)) -> 1 + (2 + 12) //Simplifying\n10. 1 + (2 + 12) -> 1 + 14 //Simplifying\n11. 1 + 14 -> 15 //Final result", "output": 15}, {"function_name": "map_recursive", "function": "def map_recursive(f, lst):\n    if not lst:\n        return []\n    else:\n        return [f(lst[0])] + map_recursive(f, lst[1:])\n\ndef square(x):\n    return x * x", "command": "map_recursive(square, [1, 2, 3, 4])", "traces": "1. map_recursive(square, [1, 2, 3, 4]) -> [square(1)] + map_recursive(square, [2, 3, 4]) //Recursive call with tail of list and applying square to the head\n2. [square(1)] + map_recursive(square, [2, 3, 4]) -> [1] + map_recursive(square, [2, 3, 4]) //square(1) = 1\n3. [1] + map_recursive(square, [2, 3, 4]) -> [1] + [square(2)] + map_recursive(square, [3, 4]) //Recursive call\n4. [1] + [square(2)] + map_recursive(square, [3, 4]) -> [1] + [4] + map_recursive(square, [3, 4]) //square(2) = 4\n5. [1] + [4] + map_recursive(square, [3, 4]) -> [1, 4] + map_recursive(square, [3, 4]) //List concatenation\n6. [1, 4] + map_recursive(square, [3, 4]) -> [1, 4] + [square(3)] + map_recursive(square, [4]) //Recursive call\n7. [1, 4] + [square(3)] + map_recursive(square, [4]) -> [1, 4] + [9] + map_recursive(square, [4]) //square(3) = 9\n8. [1, 4] + [9] + map_recursive(square, [4]) -> [1, 4, 9] + map_recursive(square, [4]) //List concatenation\n9. [1, 4, 9] + map_recursive(square, [4]) -> [1, 4, 9] + [square(4)] + map_recursive(square, []) //Recursive call\n10. [1, 4, 9] + [square(4)] + map_recursive(square, []) -> [1, 4, 9] + [16] + map_recursive(square, []) //square(4) = 16\n11. [1, 4, 9] + [16] + map_recursive(square, []) -> [1, 4, 9] + [16] + [] //Base case: empty list returns empty list\n12. [1, 4, 9] + [16] + [] -> [1, 4, 9, 16] //Final result", "output": [1, 4, 9, 16]}, {"function_name": "fibonacci_recursive", "function": "def fibonacci_recursive(n):\n    if n <= 1:\n        return n\n    else:\n        return fibonacci_recursive(n-1) + fibonacci_recursive(n-2)", "command": "fibonacci_recursive(5)", "traces": "1. fibonacci_recursive(5) -> fibonacci_recursive(4) + fibonacci_recursive(3) //Recursive calls\n2. fibonacci_recursive(4) + fibonacci_recursive(3) -> (fibonacci_recursive(3) + fibonacci_recursive(2)) + fibonacci_recursive(3) //Further recursive calls\n3. (fibonacci_recursive(3) + fibonacci_recursive(2)) + fibonacci_recursive(3) -> ((fibonacci_recursive(2) + fibonacci_recursive(1)) + (fibonacci_recursive(1) + fibonacci_recursive(0))) + (fibonacci_recursive(2) + fibonacci_recursive(1)) //More recursive calls\n4. ((fibonacci_recursive(2) + fibonacci_recursive(1)) + (fibonacci_recursive(1) + fibonacci_recursive(0))) + (fibonacci_recursive(2) + fibonacci_recursive(1)) -> (((fibonacci_recursive(1) + fibonacci_recursive(0)) + 1) + (1 + 0)) + ((fibonacci_recursive(1) + fibonacci_recursive(0)) + 1) //Base cases hit (n <=1)\n5. (((fibonacci_recursive(1) + fibonacci_recursive(0)) + 1) + (1 + 0)) + ((fibonacci_recursive(1) + fibonacci_recursive(0)) + 1) -> (((1 + 0) + 1) + (1 + 0)) + ((1 + 0) + 1) //Simplifying\n6. (((1 + 0) + 1) + (1 + 0)) + ((1 + 0) + 1) -> ((1 + 1) + 1) + (1 + 1) //Simplifying\n7. ((1 + 1) + 1) + (1 + 1) -> (2 + 1) + 2 //Simplifying\n8. (2 + 1) + 2 -> 3 + 2 //Simplifying\n9. 3 + 2 -> 5 //Final result", "output": 5}, {"function_name": "higher_order_example", "function": "def higher_order_example(x, f, g):\n    return f(g(x))\n\ndef add_one(x):\n    return x + 1\n\ndef square(x):\n  return x*x", "command": "higher_order_example(2, add_one, square)", "traces": "1. higher_order_example(2, add_one, square) -> add_one(square(2)) //Function application\n2. add_one(square(2)) -> add_one(4) //square(2) = 4\n3. add_one(4) -> 5 //add_one(4) = 5", "output": 5}, {"function_name": "filter_recursive", "function": "def filter_recursive(f, lst):\n    if not lst:\n        return []\n    else:\n        if f(lst[0]):\n            return [lst[0]] + filter_recursive(f, lst[1:])\n        else:\n            return filter_recursive(f, lst[1:])\n\ndef is_even(x):\n    return x % 2 == 0", "command": "filter_recursive(is_even, [1, 2, 3, 4, 5, 6])", "traces": "1. filter_recursive(is_even, [1, 2, 3, 4, 5, 6]) -> filter_recursive(is_even, [2, 3, 4, 5, 6]) //is_even(1) is false\n2. filter_recursive(is_even, [2, 3, 4, 5, 6]) -> [2] + filter_recursive(is_even, [3, 4, 5, 6]) //is_even(2) is true\n3. [2] + filter_recursive(is_even, [3, 4, 5, 6]) -> [2] + filter_recursive(is_even, [4, 5, 6]) //is_even(3) is false\n4. [2] + filter_recursive(is_even, [4, 5, 6]) -> [2] + [4] + filter_recursive(is_even, [5, 6]) //is_even(4) is true\n5. [2] + [4] + filter_recursive(is_even, [5, 6]) -> [2, 4] + filter_recursive(is_even, [5, 6]) //List concatenation\n6. [2, 4] + filter_recursive(is_even, [5, 6]) -> [2, 4] + filter_recursive(is_even, [6]) //is_even(5) is false\n7. [2, 4] + filter_recursive(is_even, [6]) -> [2, 4] + [6] + filter_recursive(is_even, []) //is_even(6) is true\n8. [2, 4] + [6] + filter_recursive(is_even, []) -> [2, 4] + [6] + [] //Base case: empty list returns empty list\n9. [2, 4] + [6] + [] -> [2, 4, 6] //Final result", "output": [2, 4, 6]}, {"function_name": "recursive_sum", "function": "def recursive_sum(lst):\n  if not lst:\n    return 0\n  else:\n    return lst[0] + recursive_sum(lst[1:])", "command": "recursive_sum([1,2,3,4,5])", "traces": "1. recursive_sum([1,2,3,4,5]) -> 1 + recursive_sum([2,3,4,5]) // Base case not met, recursive call.\n2. 1 + recursive_sum([2,3,4,5]) -> 1 + (2 + recursive_sum([3,4,5])) //Recursive call\n3. 1 + (2 + recursive_sum([3,4,5])) -> 1 + (2 + (3 + recursive_sum([4,5]))) //Recursive call\n4. 1 + (2 + (3 + recursive_sum([4,5]))) -> 1 + (2 + (3 + (4 + recursive_sum([5])))) //Recursive call\n5. 1 + (2 + (3 + (4 + recursive_sum([5])))) -> 1 + (2 + (3 + (4 + (5 + recursive_sum([]))))) //Recursive call\n6. 1 + (2 + (3 + (4 + (5 + recursive_sum([]))))) -> 1 + (2 + (3 + (4 + (5 + 0)))) // Base case met, recursive_sum([]) returns 0\n7. 1 + (2 + (3 + (4 + (5 + 0)))) -> 1 + (2 + (3 + (4 + 5))) // Arithmetic operation\n8. 1 + (2 + (3 + (4 + 5))) -> 1 + (2 + (3 + 9)) // Arithmetic operation\n9. 1 + (2 + (3 + 9)) -> 1 + (2 + 12) // Arithmetic operation\n10. 1 + (2 + 12) -> 1 + 14 // Arithmetic operation\n11. 1 + 14 -> 15 // Arithmetic operation", "output": 15}, {"function_name": "recursive_map", "function": "def recursive_map(func, lst):\n  if not lst:\n    return []\n  else:\n    return [func(lst[0])] + recursive_map(func, lst[1:])", "command": "recursive_map(lambda x: x*2, [1,2,3])", "traces": "1. recursive_map(lambda x: x*2, [1,2,3]) -> [(lambda x: x*2)(1)] + recursive_map(lambda x: x*2, [2,3]) //Applies lambda to first element\n2. [(lambda x: x*2)(1)] + recursive_map(lambda x: x*2, [2,3]) -> [2] + recursive_map(lambda x: x*2, [2,3]) //Lambda evaluates to 2\n3. [2] + recursive_map(lambda x: x*2, [2,3]) -> [2] + [(lambda x: x*2)(2)] + recursive_map(lambda x: x*2, [3]) //Applies lambda to next element\n4. [2] + [(lambda x: x*2)(2)] + recursive_map(lambda x: x*2, [3]) -> [2] + [4] + recursive_map(lambda x: x*2, [3]) //Lambda evaluates to 4\n5. [2] + [4] + recursive_map(lambda x: x*2, [3]) -> [2] + [4] + [(lambda x: x*2)(3)] + recursive_map(lambda x: x*2, []) //Applies lambda to next element\n6. [2] + [4] + [(lambda x: x*2)(3)] + recursive_map(lambda x: x*2, []) -> [2] + [4] + [6] + [] //Lambda evaluates to 6, base case reached\n7. [2] + [4] + [6] + [] -> [2, 4, 6] //List concatenation", "output": [2, 4, 6]}, {"function_name": "higher_order_sort", "function": "def higher_order_sort(lst, comparator):\n    if len(lst) <= 1:\n        return lst\n    pivot = lst[0]\n    less = [x for x in lst[1:] if comparator(x, pivot)]\n    greater = [x for x in lst[1:] if not comparator(x, pivot)]\n    return higher_order_sort(less, comparator) + [pivot] + higher_order_sort(greater, comparator)", "command": "higher_order_sort([3,1,4,1,5,9,2,6], lambda x,y: x<y)", "traces": "1. higher_order_sort([3,1,4,1,5,9,2,6], lambda x,y: x<y) -> ... (Recursive calls and list comprehensions will unfold, showing steps of sorting.  Too long to fully detail here.  The trace would show the recursive partitioning around pivots until a sorted list is obtained.)", "output": [1, 1, 2, 3, 4, 5, 6, 9]}, {"function_name": "fib_lambda", "function": "def fib_lambda(n):\n    fib = lambda x: x if x <= 1 else fib(x-1) + fib(x-2)\n    return fib(n)", "command": "fib_lambda(6)", "traces": "1. fib_lambda(6) -> fib(6) //Call the inner lambda function\n2. fib(6) -> fib(5) + fib(4) //Recursive call\n3. fib(5) -> fib(4) + fib(3) //Recursive call\n4. fib(4) -> fib(3) + fib(2) //Recursive call\n5. fib(3) -> fib(2) + fib(1) //Recursive call\n6. fib(2) -> fib(1) + fib(0) //Recursive call\n7. fib(1) -> 1 //Base case\n8. fib(0) -> 0 //Base case\n9. fib(2) -> 1 + 0 -> 1 //Calculation\n10. fib(3) -> 1 + 1 -> 2 //Calculation\n11. fib(4) -> 2 + 1 -> 3 //Calculation\n12. fib(5) -> 3 + 2 -> 5 //Calculation\n13. fib(6) -> 5 + 3 -> 8 //Calculation", "output": 8}, {"function_name": "nested_lambda", "function": "def nested_lambda(x,y):\n    add = lambda a,b: a+b\n    mult = lambda a,b: a*b\n    return add(x, mult(y,2))", "command": "nested_lambda(5,3)", "traces": "1. nested_lambda(5,3) -> add(5, mult(3,2)) //Function call\n2. add(5, mult(3,2)) -> add(5, (lambda a,b: a*b)(3,2)) //inner lambda call\n3. add(5, (lambda a,b: a*b)(3,2)) -> add(5, 6) //Inner lambda evaluates to 6\n4. add(5, 6) -> (lambda a,b: a+b)(5,6) //Inner lambda call\n5. (lambda a,b: a+b)(5,6) -> 11 //Inner lambda evaluates to 11", "output": 11}, {"function_name": "recursive_sum", "function": "def recursive_sum(lst):\n    if not lst:\n        return 0\n    else:\n        return lst[0] + recursive_sum(lst[1:])", "command": "recursive_sum([1, 2, 3, 4, 5])", "traces": "1. recursive_sum([1, 2, 3, 4, 5]) -> 1 + recursive_sum([2, 3, 4, 5]) // Base case not met, recursive call\n2. 1 + recursive_sum([2, 3, 4, 5]) -> 1 + (2 + recursive_sum([3, 4, 5])) // Recursive call\n3. 1 + (2 + recursive_sum([3, 4, 5])) -> 1 + (2 + (3 + recursive_sum([4, 5]))) // Recursive call\n4. 1 + (2 + (3 + recursive_sum([4, 5]))) -> 1 + (2 + (3 + (4 + recursive_sum([5])))) // Recursive call\n5. 1 + (2 + (3 + (4 + recursive_sum([5])))) -> 1 + (2 + (3 + (4 + (5 + recursive_sum([]))))) // Recursive call\n6. 1 + (2 + (3 + (4 + (5 + recursive_sum([]))))) -> 1 + (2 + (3 + (4 + (5 + 0)))) // Base case met, returns 0\n7. 1 + (2 + (3 + (4 + (5 + 0)))) -> 1 + (2 + (3 + (4 + 5))) // Arithmetic\n8. 1 + (2 + (3 + (4 + 5))) -> 1 + (2 + (3 + 9)) // Arithmetic\n9. 1 + (2 + (3 + 9)) -> 1 + (2 + 12) // Arithmetic\n10. 1 + (2 + 12) -> 1 + 14 // Arithmetic\n11. 1 + 14 -> 15 // Arithmetic", "output": 15}, {"function_name": "map_lambda", "function": "def map_lambda(func, lst):\n    if not lst:\n        return []\n    else:\n        return [func(lst[0])] + map_lambda(func, lst[1:])\n\n", "command": "map_lambda(lambda x: x*2, [1,2,3])", "traces": "1. map_lambda(lambda x: x*2, [1,2,3]) -> [ (lambda x: x*2)(1) ] + map_lambda(lambda x: x*2, [2,3]) //recursive call\n2. [ (lambda x: x*2)(1) ] + map_lambda(lambda x: x*2, [2,3]) -> [2] + map_lambda(lambda x: x*2, [2,3]) //lambda application\n3. [2] + map_lambda(lambda x: x*2, [2,3]) -> [2] + [ (lambda x: x*2)(2) ] + map_lambda(lambda x: x*2, [3]) //recursive call\n4. [2] + [ (lambda x: x*2)(2) ] + map_lambda(lambda x: x*2, [3]) -> [2] + [4] + map_lambda(lambda x: x*2, [3]) //lambda application\n5. [2] + [4] + map_lambda(lambda x: x*2, [3]) -> [2] + [4] + [ (lambda x: x*2)(3) ] + map_lambda(lambda x: x*2, []) //recursive call\n6. [2] + [4] + [ (lambda x: x*2)(3) ] + map_lambda(lambda x: x*2, []) -> [2] + [4] + [6] + [] //lambda application and base case\n7. [2] + [4] + [6] + [] -> [2, 4, 6] //list concatenation", "output": "[2, 4, 6]"}, {"function_name": "fib_recursive", "function": "def fib_recursive(n):\n    if n <= 1:\n        return n\n    else:\n        return fib_recursive(n-1) + fib_recursive(n-2)", "command": "fib_recursive(5)", "traces": "1. fib_recursive(5) -> fib_recursive(4) + fib_recursive(3) //recursive call\n2. fib_recursive(4) + fib_recursive(3) -> (fib_recursive(3) + fib_recursive(2)) + fib_recursive(3) //recursive call\n3. (fib_recursive(3) + fib_recursive(2)) + fib_recursive(3) -> ((fib_recursive(2) + fib_recursive(1)) + fib_recursive(2)) + fib_recursive(3) //recursive call\n4. ((fib_recursive(2) + fib_recursive(1)) + fib_recursive(2)) + fib_recursive(3) -> ((fib_recursive(1) + fib_recursive(0)) + fib_recursive(2)) + fib_recursive(3) //recursive call\n5. ((fib_recursive(1) + fib_recursive(0)) + fib_recursive(2)) + fib_recursive(3) -> ((1 + 0) + fib_recursive(2)) + fib_recursive(3) //base cases\n6. ((1 + 0) + fib_recursive(2)) + fib_recursive(3) -> ((1 + 0) + (fib_recursive(1) + fib_recursive(0))) + fib_recursive(3) //recursive call\n7. ((1 + 0) + (fib_recursive(1) + fib_recursive(0))) + fib_recursive(3) -> ((1 + 0) + (1 + 0)) + fib_recursive(3) //base cases\n8. ((1 + 0) + (1 + 0)) + fib_recursive(3) -> (1 + 1) + fib_recursive(3) //arithmetic\n9. (1 + 1) + fib_recursive(3) -> 2 + fib_recursive(3) //arithmetic\n10. 2 + fib_recursive(3) -> 2 + (fib_recursive(2) + fib_recursive(1)) //recursive call\n11. 2 + (fib_recursive(2) + fib_recursive(1)) -> 2 + ((fib_recursive(1) + fib_recursive(0)) + 1) //recursive call\n12. 2 + ((fib_recursive(1) + fib_recursive(0)) + 1) -> 2 + ((1 + 0) + 1) //base cases\n13. 2 + ((1 + 0) + 1) -> 2 + (1 + 1) //arithmetic\n14. 2 + (1 + 1) -> 2 + 2 //arithmetic\n15. 2 + 2 -> 4 //arithmetic", "output": 5}, {"function_name": "higher_order_filter", "function": "def higher_order_filter(func, lst):\n    if not lst:\n        return []\n    else:\n        return [lst[0]] + higher_order_filter(func, lst[1:]) if func(lst[0]) else higher_order_filter(func, lst[1:])", "command": "higher_order_filter(lambda x: x > 2, [1, 3, 2, 4, 5])", "traces": "1. higher_order_filter(lambda x: x > 2, [1, 3, 2, 4, 5]) -> higher_order_filter(lambda x: x > 2, [3, 2, 4, 5]) // 1 > 2 is false\n2. higher_order_filter(lambda x: x > 2, [3, 2, 4, 5]) -> [3] + higher_order_filter(lambda x: x > 2, [2, 4, 5]) // 3 > 2 is true\n3. [3] + higher_order_filter(lambda x: x > 2, [2, 4, 5]) -> [3] + higher_order_filter(lambda x: x > 2, [4, 5]) // 2 > 2 is false\n4. [3] + higher_order_filter(lambda x: x > 2, [4, 5]) -> [3] + [4] + higher_order_filter(lambda x: x > 2, [5]) // 4 > 2 is true\n5. [3] + [4] + higher_order_filter(lambda x: x > 2, [5]) -> [3] + [4] + [5] + higher_order_filter(lambda x: x > 2, []) // 5 > 2 is true\n6. [3] + [4] + [5] + higher_order_filter(lambda x: x > 2, []) -> [3] + [4] + [5] + [] // base case\n7. [3] + [4] + [5] + [] -> [3, 4, 5] // list concatenation", "output": "[3, 4, 5]"}, {"function_name": "compose_lambdas", "function": "def compose_lambdas(f, g, x):\n    return f(g(x))", "command": "compose_lambdas(lambda x: x * 2, lambda x: x + 1, 5)", "traces": "1. compose_lambdas(lambda x: x * 2, lambda x: x + 1, 5) -> (lambda x: x * 2)((lambda x: x + 1)(5)) // Function application\n2. (lambda x: x * 2)((lambda x: x + 1)(5)) -> (lambda x: x * 2)(5 + 1) //Inner lambda application\n3. (lambda x: x * 2)(5 + 1) -> (lambda x: x * 2)(6) //Arithmetic\n4. (lambda x: x * 2)(6) -> 6 * 2 //Lambda application\n5. 6 * 2 -> 12 //Arithmetic", "output": 12}]